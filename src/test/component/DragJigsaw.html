<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>研究滑块拼图的破解方案</title>
    <style>
        html, body {
            padding: 0;
            margin: 0;
        }

        body canvas {
            display: block;
            margin: 12px auto;
        }
    </style>
</head>
<body>

    <script>
        (async () => {
            function req(method, url) {
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open(method, url);
                    xhr.onload = () => resolve(xhr);
                    xhr.onerror = reject;
                    xhr.send();
                });
            }

            async function createImgCanvas(imgBase64) {
                return new Promise(resolve => {
                    const img = document.createElement("img");
                    img.onload = () => {
                        const canvas = document.createElement("canvas");
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const context = canvas.getContext("2d");
                        context.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve([canvas, context]);
                    };
                    img.src = "data:image/jpeg;base64, " + imgBase64;
                });
            }

            const dragJigsaw = JSON.parse((await req("GET", "../../../lib/test/component/dragJigsaw.json")).responseText);
            const gapMaskColor = dragJigsaw.gapMaskColor;

            // 需要先运行一次 src/test/component/DragJigsawTest1 或 src/test/component/DragJigsawTest2 来生成对应的验证码截图
            const [canvas0, context0] = await createImgCanvas(dragJigsaw.img0);
            const [canvas1, context1] = await createImgCanvas(dragJigsaw.img1);
            const [canvas2, context2] = await createImgCanvas(dragJigsaw.img0);
            document.body.appendChild(canvas0);
            document.body.appendChild(canvas1);
            document.body.appendChild(canvas2);

            // start
            const colorGray = colorArr => {
                const grayArr = [];
                for (let i = 0; i < colorArr.length; i += 4) {
                    // 灰度计算 参考 https://blog.csdn.net/xdrt81y/article/details/8289963
                    const gray = (colorArr[i] * 19595 + colorArr[i + 1] * 38469 + colorArr[i + 2] * 7472) >> 16;
                    grayArr.push(gray);
                }
                return grayArr;
            };

            const colorDiff = (arr0, arr1) => {
                const gray0 = colorGray(arr0);
                const gray1 = colorGray(arr1);
                let diff = 0;
                let diffCount = 0;
                for (let i = 0; i < gray0.length; i++) {
                    const delta = Math.abs(gray0[i] - gray1[i]);
                    diff += delta;
                    if (delta) {
                        diffCount++;
                    }
                }
                return diff / (diffCount || 1);
            };

            // 颜色混合
            // 参考 https://stackoverflow.com/questions/12011081/alpha-blending-2-rgba-colors-in-c
            const mixColor = (backRgba, frontRgba) => {
                const alpha = frontRgba[3] + 1;
                const invAlpha = 256 - frontRgba[3];
                return [
                    (alpha * frontRgba[0] + invAlpha * backRgba[0]) >> 8,
                    (alpha * frontRgba[1] + invAlpha * backRgba[1]) >> 8,
                    (alpha * frontRgba[2] + invAlpha * backRgba[2]) >> 8,
                    255
                ];
            };

            const mixColors = (backColors, fronRgba) => {
                const mixedColors = [];
                for (let i = 0; i < backColors.length; i += 4) {
                    const mixedColor = mixColor(backColors.subarray(i, i + 4), fronRgba);
                    mixedColor.forEach(item => mixedColors.push(item));
                }
                return mixedColors;
            };

            let maskEdgeL = null;
            let maskEdgeR = null;
            let maskEdgeT = null;
            let maskEdgeB = null;

            for (let x = 0; x < 80; x++) {
                const diff = colorDiff(
                    context0.getImageData(x, 0, 1, canvas0.height).data,
                    context1.getImageData(x, 0, 1, canvas0.height).data);
                if (diff > 20) {
                    if (maskEdgeL == null) {
                        maskEdgeL = x;
                    }
                    maskEdgeR = x;
                }
            }

            for (let y = 0; y < canvas0.height; y++) {
                const diff = colorDiff(
                    context0.getImageData(0, y, canvas0.width, 1).data,
                    context1.getImageData(0, y, canvas0.width, 1).data);
                if (diff > 20) {
                    if (maskEdgeT == null) {
                        maskEdgeT = y;
                    }
                    maskEdgeB = y;
                }
            }

            if (context2) {
                context2.fillStyle = `rgba(0,0,0,0.45)`;
                context2.fillRect(maskEdgeL, 0, 1, canvas0.height);
                context2.fillRect(maskEdgeR, 0, 1, canvas0.height);
                context2.fillRect(0, maskEdgeT, canvas0.width, 1);
                context2.fillRect(0, maskEdgeB, canvas0.width, 1);
            }

            // 只检验正中央的部分
            let maskCenterL = maskEdgeL;
            let maskCenterR = maskEdgeR;
            let maskCenterT = maskEdgeT;
            let maskCenterB = maskEdgeB;
            const centerCheckSize = 28;
            if (maskCenterR - maskCenterL >= centerCheckSize) {
                const delta = (maskCenterR - maskCenterL - centerCheckSize) / 2;
                maskCenterL += delta;
                maskCenterR -= delta;
            }
            if (maskCenterB - maskCenterT >= centerCheckSize) {
                const delta = (maskCenterB - maskCenterT - centerCheckSize) / 2;
                maskCenterT += delta;
                maskCenterB -= delta;
            }

            if (context2) {
                context2.fillStyle = `rgba(0,0,0,0.4)`;
                context2.fillRect(maskCenterL, maskCenterT, maskCenterR - maskCenterL, maskCenterB - maskCenterT);
            }

            const possibleDesRects = [];
            const maskColors = context0.getImageData(maskCenterL, maskCenterT, maskCenterR - maskCenterL, maskCenterB - maskCenterT).data;
            for (let alpha = 0.3; alpha <= 0.7; alpha += 0.05) {
                const grayMask = [...gapMaskColor, 255 * alpha];
                const mixedColors = mixColors(maskColors, grayMask);
                for (let xDelta = 45; xDelta < canvas0.width - 50; xDelta++) {
                    const checkColors = context0.getImageData(maskCenterL + xDelta, maskCenterT, maskCenterR - maskCenterL, maskCenterB - maskCenterT).data;
                    const diff = colorDiff(mixedColors, checkColors);
                    if (diff < 25) {
                        if (possibleDesRects.length > 0 && possibleDesRects[0].diff < diff) {

                        }
                        else {
                            if (possibleDesRects.length > 0 && possibleDesRects[0].diff > diff) {
                                possibleDesRects.splice(0, possibleDesRects.length);
                            }
                            possibleDesRects.push({
                                diff: diff,
                                alpha: alpha,
                                delta: xDelta
                            });
                        }
                    }
                }
            }
            if (possibleDesRects.length) {
                // 如果仅通过 diff 判定出多个最优解，则还需要通过扩大mask的范围，一直到diff有唯一最小值
                let spreadSize = 1;
                while (possibleDesRects.length > 1) {
                    const maskColors = context0.getImageData(maskCenterL - spreadSize, maskCenterT - spreadSize, maskCenterR - maskCenterL + spreadSize * 2, maskCenterB - maskCenterT + spreadSize * 2).data;
                    for (let item of possibleDesRects) {
                        const grayMask = [...gapMaskColor, 255 * item.alpha];
                        const mixedColors = mixColors(maskColors, grayMask);
                        const checkColors = context0.getImageData(maskCenterL - spreadSize + item.delta, maskCenterT - spreadSize, maskCenterR - maskCenterL + spreadSize * 2, maskCenterB - maskCenterT + spreadSize * 2).data;
                        item.spreadDiff = colorDiff(mixedColors, checkColors);
                        item.spreadSize = spreadSize;
                    }
                    possibleDesRects.sort((o1, o2) => o1.spreadDiff - o2.spreadDiff);
                    for (let i = 1; i < possibleDesRects.length; i++) {
                        if (possibleDesRects[i].spreadDiff !== possibleDesRects[0].spreadDiff) {
                            possibleDesRects.splice(i, possibleDesRects.length - i);
                            break;
                        }
                    }
                    spreadSize++;
                }

                const bestDesRect = possibleDesRects[0];
                if (context2) {
                    context2.fillStyle = `rgba(255,120,0,0.4)`;
                    context2.fillRect(bestDesRect.delta + maskCenterL, maskCenterT, maskCenterR - maskCenterL, maskCenterB - maskCenterT);
                    possibleDesRects.forEach(item => console.log(item));
                    console.log("拖动距离：" + bestDesRect.delta);
                }

                return bestDesRect.delta;
            }
            // end

        })();
    </script>
</body>
</html>